-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun mkOps () {
  fun mkBinop (l, op, r) {
    Binop (op, l, r)
  }

  var ops = {
    [Left, {"!!"}],
    [Left, {"&&"}],
    [Nona, {"==", "!=", "<=", "<", ">=", ">"}],
    [Left, {"+", "-"}],
    [Left, {"*", "/", "%"}]
  };

  map (fun ([lnr, lops]) {
    [lnr, map (fun (op) { [s (op), mkBinop] }, lops)]
  } , ops)
}

-- Primary expression
var primary = 
      memo $ eta syntax (
          x=decimal { Const (stringInt (x)) } 
        | x=lident  { Var (x) }               
        | inbr[s ("("), exp, s (")") ]
      ),
    exp = memo $ eta (expr (mkOps (), primary));

var ifEnd =
      memo $ eta syntax (
          kElse s=stmt { s }
        | kElif e=exp kThen st=stmt sf=ifEnd { If (e, st, sf) }
        | kElif e=exp kThen s=stmt { If (e, s, Skip) }
      ),
    stmt_ = 
      memo $ eta syntax (
          l=lident s [":="] e=exp { Assn (l, e) }                 -- Assn
        | kSkip { Skip }                                          -- Skip
        | kRead i=inbr[s ("("), lident, s (")")] { Read (i) }     -- Read
        | kWrite i=inbr[s ("("), exp, s (")")] { Write (i) }      -- Write
        | kIf e=exp kThen st=stmt kFi { If (e, st, Skip) }        -- If
        | kIf e=exp kThen st=stmt sf=ifEnd kFi { If (e, st, sf) } -- If + Else
        | kWhile e=exp kDo s=stmt kOd { While (e, s) }            -- While
        | kDo s=stmt kWhile e=exp kOd { DoWhile (s, e) }          -- DoWhile
        | kFor s1=stmt s [","] e=exp s [","] s2=stmt 
            kDo s3=stmt kOd { Seq (s1, While (e, Seq (s3, s2))) }
      ),
    stmt = 
      memo $ eta syntax (
          stmt_
        | l=stmt_ s [";"] r=stmt { Seq (l, r) }
      );

-- Public top-level parser
public parse = stmt;
             
